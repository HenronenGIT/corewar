/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   generator.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: okoponen <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/11/09 12:47:39 by okoponen          #+#    #+#             */
/*   Updated: 2022/11/09 12:47:40 by okoponen         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/asm.h"

/*
	generate agument type code by making an 8-bit binary number from types,
	where all types have their own 2 bit code. T_REG = 01, T_DIR = 10,
	T_IND = 11. Empty spots will be 00. Saving code in decimal int form in data.
*/
static void	print_statement(t_input *data, int fd)
{
	int	i;
	int	temp;

	i = 0;
	temp = 0;
	write(fd, &data->op_code, 1);
	if (data->argument_type_code)
		write(fd, &data->argument_type_code, 1);
	while (data->arg_size[i])
	{	
		if (data->arg_size[i] == 1)
			temp = data->arg_values[i];
		else
			temp = int_to_bigendian(data->arg_values[i], data->arg_size[i]);
		write(fd, &temp, data->arg_size[i]);
		i++;
	}
}

/*
	Generate argument type code in binary and convert it into an integer value.
	ATC is generated by looping through argument types and adding the 
	corresponding binary values into a string.
*/
void	save_atc(t_input *data)
{
	char	*atc_bi;
	int		i;

	i = 0;
	atc_bi = (char *)malloc(sizeof(char) * 9);
	if (!atc_bi)
		exit (1); //change to error
	atc_bi[8] = '\0';
	while (i <= 3)
	{
		if (data->arg_type[i] == T_REG)
			atc_bi = ft_strjoin(atc_bi, "01");
		if (data->arg_type[i] == T_DIR)
			atc_bi = ft_strjoin(atc_bi, "10");
		if (data->arg_type[i] == T_IND)
			atc_bi = ft_strjoin(atc_bi, "11");
		if (!data->arg_type[i])
			atc_bi = ft_strjoin(atc_bi, "00");
		i++;
	}
	data->argument_type_code = ft_btoi(atc_bi);
	free (atc_bi);
}

/*
	find numeric value in T_DIR, T_REG or T_IND type argument when argument 
	also has characters (r or &)
*/
int	find_number(char *current_arg)
{
	int	i;

	i = 0;
	if (current_arg[0] == '%' || current_arg[0] == 'r')
		i++;
	return (ft_atoi(&current_arg[i]));
}

int	is_label_call(char *current_arg)
{
	int	i;

	i = 0;
	while (current_arg[i])
	{
		if (current_arg[i] == ':')
			return (1);
		i++;
	}
	return (0);
}

/*
	Strcmp but we skip the first characters of the name if they are : or %.
	Compare two labels, if the names match we return 1, else we return 0.
*/
int	compare_labels(char *original_label, char *current_label)
{
	int	i;
	int	j;

	i = 0;
	j = 0;
	while (original_label[i] || current_label[j])
	{
		while (original_label[i] == ':' || original_label[i] == '%')
			i++;
		while (current_label[j] == ':' || current_label[j] == '%')
			j++;
		if (original_label[i] != current_label[j])
			return (0);
		if (original_label[i])
			i++;
		if (current_label[j])
			j++;
	}
	return (1);
}

/*
	function to loop through saved labels and compare their names to the label
	we are currently searching through. When we get a match we can substract
	the address our current postion from the address of that label to find
	the relative position of that label. 
*/
void	find_label_addr(t_input **array, char *curr_label_name, int curr_arg, \
						int curr_struct)
{
	int	i;

	i = 0;
	while (array[i])
	{
		if (array[i]->label_name)
		{
			if (compare_labels(array[i]->label_name, curr_label_name))
			{
				array[curr_struct]->arg_values[curr_arg] = \
				array[i]->current_bytes - array[curr_struct]->current_bytes;
				return ;
			}
		}
		i++;
	}
	if (!array[i])
		syntax_error(UNDEFINED_LABEL_ERR, NULL, curr_label_name);
}

/*
	save values in int form for all arguments
*/
void	save_argument_values(t_input **original_data, t_input *data, \
							int current_arg, int curr_struct)
{
	if (is_label_call(data->args[current_arg]))
		find_label_addr(original_data, data->args[current_arg], current_arg, \
		curr_struct);
	else
		data->arg_values[current_arg] = find_number(data->args[current_arg]);
}

/*
	generate input value for argument type code and for different arguments of a
	single statement
*/
void	generate_input(t_input **original_data, t_input *data, int curr_struct)
{
	int	i;

	i = 0;
	if (g_op_tab[data->op_code - 1].arg_type_code != 0)
		save_atc(data);
	while (data->args[i])
	{
		save_argument_values(original_data, data, i, curr_struct);
		i++;
	}
}

/*
	test function
*/
void	print_array(t_input *data)
{
	printf("op_code: %d\n", data->op_code);
	printf("a1 size: %d\n", data->arg_size[0]);
	printf("a2 size: %d\n", data->arg_size[1]);
	printf("a3 size: %d\n", data->arg_size[2]);
	printf("a1 type: %d\n", data->arg_type[0]);
	printf("a2 type: %d\n", data->arg_type[1]);
	printf("a3 type: %d\n", data->arg_type[2]);
	printf("arg1: %s\n", data->args[0]);
	printf("arg2: %s\n", data->args[1]);
	printf("arg3: %s\n", data->args[2]);
	printf("atc: %d\n", data->argument_type_code);
	printf("arg1_value: %d\n", data->arg_values[0]);
	printf("arg2_value: %d\n", data->arg_values[1]);
	printf("arg3_value: %d\n", data->arg_values[2]);
	printf("-----------------\n");
}

/*
	loop through all statements and labels and generate input for each
	statement, skipping labels
*/
void	generator(t_vec *vec_input, int fd)
{
	int		i;
	t_input	**data;

	i = 0;
	data = (t_input **)vec_input->array;
	while (data[i])
	{
		if (!data[i]->label_name)
		{
			generate_input(data, data[i], i);
//			print_array(data[i]);
			print_statement(data[i], fd);
		}
		i++;
	}
}
